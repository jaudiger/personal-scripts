#!/usr/bin/env nu
#
# Copyright (c) JÃ©rÃ©my Audiger.
# All rights reserved.
#

use mod.nu *
use std

const GIT_DEFAULT_BRANCH = "main"
const GIT_OLD_DEFAULT_BRANCH = "master"

# TODO: Wait the following issues before to enable the reftable option:
# - https://github.com/starship/starship/issues/6086
# - https://github.com/zed-industries/zed/issues/14414
# const GIT_CLONE_DEFAULT_ARGS = ["--quiet", "--ref-format=reftable", "--recurse-submodules", "--shallow-submodules", "-j2"]
const GIT_CLONE_DEFAULT_ARGS = ["--quiet", "--recurse-submodules", "--shallow-submodules", "-j2"]

def check-uncommit [repo: string; quiet: bool; dry_run: bool]: nothing -> bool {
    let result = ^git -C $repo status --porcelain
    if ($result | is-not-empty) {
        if not $quiet {
            print $"Uncommitted changes in ($repo):\n($result)"
        }

        if not $dry_run {
            let result = input "Do you want to remove the uncommitted changes [y/N]: "
            if ($result == "y") {
                ^git -C $repo reset --hard
                ^git -C $repo clean -qfd
            }
        }

        print ""

        return true
    }

    return false
}

def check-stash [repo: string; quiet: bool; dry_run: bool]: nothing -> bool {
    let result = ^git -C $repo stash list
    if ($result | is-not-empty) {
        if not $quiet {
            print $"Stash entries in ($repo):\n($result)"
        }

        if not $dry_run {
            let result = input "Do you want to remove the stash entries [y/N]: "
            if ($result == "y") {
                ^git -C $repo stash clear
            }
        }

        print ""

        return true
    }

    return false
}

def check-branch [repo: string; branch: string; up_to_date: bool; quiet: bool; dry_run: bool]: nothing -> bool {
    let git_local_branch = (^git -C $repo branch --show-current | str trim)
    if not ($git_local_branch | str contains $branch) {
        if ($git_local_branch == $GIT_OLD_DEFAULT_BRANCH and $branch == $GIT_DEFAULT_BRANCH) {
            # Silently handle the case where the local branch is the old default branch and the expected branch is the new default branch
            return true
        }

        if not $quiet {
            print $"Current branch '($git_local_branch)' of ($repo) is not the expected branch '($branch)'"
        }

        if not $dry_run {
            let result = input "Do you want to change the branch [y/N]: "
            if ($result == "y") {
                ^git -C $repo checkout $branch
            }
        }

        return true
    }

    if $up_to_date {
        ^git -C $repo fetch out+err> (std null-device)

        # Ensure that the remote branch does exist
        let remote_branch = (^git -C $repo ls-remote --heads origin $git_local_branch)
        if ($remote_branch | is-empty) {
            if not $quiet {
                print $"Remote branch '($git_local_branch)' does not exist in ($repo)"
            }

            return true
        }

        let git_local_commit = (^git -C $repo rev-parse $git_local_branch)
        let git_remote_commit = (^git -C $repo rev-parse origin/($git_local_branch))

        if ($git_local_commit != $git_remote_commit) {
            if not $quiet {
                print $"Current branch '($git_local_branch)' of ($repo) is not up to date with the remote branch"
            }

            if not $dry_run {
                let result = input "Do you want to pull the changes [y/N]: "
                if ($result == "y") {
                    ^git -C $repo pull out+err> (std null-device)
                }
            }

            return true
        }
    }

    return false
}

def gitlab-get-pr [source_branch: string]: nothing -> record {
    let gitlab_mr = (^glab mr list --source-branch=($source_branch) --output=json | from json)
    if ($gitlab_mr | length) > 0 {
        return ($gitlab_mr | get 0)
    }

    return {}
}

def git-clone [git_main_host: string; repo: string; output_folder: string; quiet: bool; dry_run: bool]: nothing -> nothing {
    if not $quiet {
        print $"Cloning ($repo)..."
    }

    if not $dry_run {
        ^git clone ...$GIT_CLONE_DEFAULT_ARGS $"($git_main_host)($repo).git" $output_folder
    }
}

def git-clone-non-empty-folder [git_main_host: string; repo: string; output_folder: string; quiet: bool; dry_run: bool]: nothing -> nothing {
    if not $quiet {
        print $"Finish initialization of ($repo)..."
    }

    if not $dry_run {
        let temp_dir = mktemp -d
        ^git clone ...$GIT_CLONE_DEFAULT_ARGS $"($git_main_host)($repo).git" $temp_dir

        for content in (ls -a $temp_dir) {
            ^mv $content.name $output_folder
        }
    }
}

def git-sync [repo: string; branch: bool, tag: bool, submodule: bool, quiet: bool; dry_run: bool]: nothing -> nothing {
    if not $quiet {
        print $"Syncing ($repo)..."
    }

    if not $dry_run {
        # Handle first the tags pruning, since it'll also do a global repository fetch
        # In case of no tags pruning, fetch normally the repository
        if $tag {
            ^git -C $repo fetch --tags --prune-tags --force
        } else {
            ^git -C $repo fetch
        }

        if $branch {
            ^git -C $repo for-each-ref --format "%(refname:short) %(upstream:short)" "refs/heads"
                | lines
                | parse "{local} {upstream}"
                | where { $in.upstream | is-not-empty }
                | where { |row|
                    (^git -C $repo show-ref --quiet $"refs/remotes/($in.upstream)" | complete).exit_code != 0
                }
                | each { |row|
                    ^git -C $repo branch -D $row.local
                }
        }

        if $submodule and (".gitmodules" | path exists) {
            let submodule_status = (^git -C $repo submodule status --recursive)
            let needs_update = ($submodule_status | lines | any { |line| ($line | str starts-with "+") or ($line | str starts-with "-") })

            if $needs_update {
                ^git -C $repo submodule deinit --force . out+err> (std null-device)
                ^git -C $repo submodule update --init --recursive --depth 1 out+err> (std null-device)
            }
        }
    }
}

def git-cleanup [repo: string; quiet: bool; dry_run: bool]: nothing -> nothing {
    if not $quiet {
        print $"Cleaning up ($repo)..."
    }

    if not $dry_run {
        ^git -C $repo gc out+err> (std null-device)
    }
}

# Analyze repository and return backup reasons
def analyze-repo-backup [repo: string]: nothing -> record {
    # Handle edge case: no commits yet
    let has_commits = (^git -C $repo rev-parse HEAD err> (std null-device) | complete).exit_code == 0

    # Check if repository has no remotes configured
    let no_remotes = (^git -C $repo remote | str trim) | is-empty

    # Check if repository has dirty working tree
    let dirty_files = ^git -C $repo status --porcelain | lines
    let dirty = ($dirty_files | is-not-empty)

    # Check if repository has stashes
    let stash_list = ^git -C $repo stash list | lines
    let stashes = ($stash_list | is-not-empty)

    # Get list of local-only branches (no upstream tracking)
    let local_only_branches = if $has_commits {
        ^git -C $repo for-each-ref --format='%(refname:short) %(upstream)' refs/heads
            | lines
            | parse "{branch} {upstream}"
            | where { $in.upstream | is-empty }
            | get branch
    } else { [] }

    # Get list of branches ahead of their remote
    let ahead_branches = if $has_commits {
        ^git -C $repo for-each-ref --format='%(refname:short) %(upstream:trackshort)' refs/heads
            | lines
            | parse "{branch} {status}"
            | where { $in.status | str contains ">" }
    } else { [] }

    let needs_backup = $no_remotes or $dirty or $stashes or ($local_only_branches | is-not-empty) or ($ahead_branches | is-not-empty)

    # Bundle is only needed when there's local-only git data (not just stashes/dirty files)
    let needs_bundle = $no_remotes or ($local_only_branches | is-not-empty) or ($ahead_branches | is-not-empty)

    {
        needs_backup: $needs_backup
        needs_bundle: $needs_bundle
        has_commits: $has_commits
        no_remotes: $no_remotes
        dirty: $dirty
        dirty_files: $dirty_files
        stashes: $stashes
        stash_list: $stash_list
        local_only_branches: $local_only_branches
        ahead_branches: $ahead_branches
    }
}

# Generate README.md content for backup
def generate-backup-readme [repo: string, analysis: record, timestamp: string]: nothing -> string {
    mut content = $"# Backup of ($repo)\n\n"
    $content += $"**Original path:** `($repo)`\n"
    $content += $"**Backup timestamp:** ($timestamp)\n\n"

    $content += "## Backup Triggers\n\n"
    if $analysis.no_remotes { $content += "- No remotes configured\n" }
    if $analysis.dirty { $content += "- Dirty working tree\n" }
    if $analysis.stashes { $content += "- Stashes exist\n" }
    if ($analysis.local_only_branches | is-not-empty) { $content += "- Local-only branches\n" }
    if ($analysis.ahead_branches | is-not-empty) { $content += "- Branches ahead of remote\n" }

    if $analysis.dirty {
        $content += "\n## Dirty Files\n\n```\n"
        $content += ($analysis.dirty_files | str join "\n")
        $content += "\n```\n"
    }

    if $analysis.stashes {
        $content += "\n## Stashes\n\n```\n"
        $content += ($analysis.stash_list | str join "\n")
        $content += "\n```\n"
    }

    if ($analysis.local_only_branches | is-not-empty) {
        $content += "\n## Local-only Branches\n\n"
        for branch in $analysis.local_only_branches {
            $content += $"- ($branch)\n"
        }
    }

    if ($analysis.ahead_branches | is-not-empty) {
        $content += "\n## Branches Ahead of Remote\n\n"
        for item in $analysis.ahead_branches {
            $content += $"- ($item.branch)\n"
        }
    }

    $content += "\n## Restoration Instructions\n\n"

    if $analysis.needs_bundle {
        $content += "### Restore from bundle\n\n"
        $content += "```bash\n"
        $content += "git clone bundle.git restored-repo\n"
        $content += "```\n\n"
    }

    if $analysis.stashes {
        $content += "### Restore stashes\n\n"
        $content += "```bash\n"
        if $analysis.needs_bundle {
            $content += "cd restored-repo\n"
            $content += "git apply ../stash-0.patch  # Apply as working changes\n"
        } else {
            $content += "# Apply to existing repo clone\n"
            $content += "git apply stash-0.patch  # Apply as working changes\n"
        }
        $content += "git stash                    # Re-stash if needed\n"
        $content += "```\n\n"
    }

    if $analysis.dirty {
        $content += "### Restore working tree changes\n\n"
        $content += "```bash\n"
        if $analysis.needs_bundle {
            $content += "tar -xzf working-tree.tar.gz -C restored-repo/\n"
        } else {
            $content += "# Extract to existing repo clone\n"
            $content += "tar -xzf working-tree.tar.gz -C <your-repo-path>/\n"
        }
        $content += "```\n"
    }

    $content
}

# Execute backup for a single repository into temp directory
def backup-repo [
    repo: string
    temp_base: string
    analysis: record
    quiet: bool
    dry_run: bool
]: nothing -> nothing {
    let timestamp = (date now | format date "%Y-%m-%d_%H-%M-%S")

    # Calculate relative path for archive structure
    let repo_path = ($repo | path expand)
    let home = $nu.home-path
    let relative_path = if ($repo_path | str starts-with $home) {
        $repo_path | str replace $home "" | str trim --char "/"
    } else {
        $repo_path | str trim --left --char "/"
    }

    if $dry_run {
        if $analysis.needs_bundle and $analysis.has_commits {
            print $"  Would include: ($relative_path)/bundle.git"
        }
        if $analysis.dirty {
            print $"  Would include: ($relative_path)/working-tree.tar.gz"
        }
        if $analysis.stashes {
            let stash_count = ($analysis.stash_list | length)
            print $"  Would include: ($relative_path)/stash-*.patch \(($stash_count) files\)"
        }
        print $"  Would include: ($relative_path)/README.md"
        return
    }

    let temp_dir = $temp_base | path join $relative_path

    if not $quiet {
        print $"Backing up ($repo)..."
    }

    # Create temp directory
    mkdir $temp_dir

    # Create git bundle with all refs (only when there's local-only git data)
    if $analysis.needs_bundle and $analysis.has_commits {
        let bundle_path = $temp_dir | path join "bundle.git"
        ^git -C $repo bundle create $bundle_path --all
    }

    # Create working tree tarball if dirty
    if $analysis.dirty {
        let tarball_path = $temp_dir | path join "working-tree.tar.gz"
        ^tar -czf $tarball_path -C $repo --exclude='.git' .
    }

    # Export stashes as patches
    if $analysis.stashes {
        let stash_count = ($analysis.stash_list | length)
        for i in 0..<$stash_count {
            let patch_path = $temp_dir | path join $"stash-($i).patch"
            ^git -C $repo stash show -p $"stash@{($i)}" | save -f $patch_path
        }
    }

    # Generate and write README
    let readme_content = generate-backup-readme $repo $analysis $timestamp
    let readme_path = $temp_dir | path join "README.md"
    $readme_content | save -f $readme_path
}

# Check if the current branch is in conflict with remote branches
def "main branch conflict" [
    --mr # Add a comment on the merge request if a conflict is found
]: nothing -> nothing {
    # Ensure the branches are up to date
    git fetch

    let git_remote = (^git remote get-url origin)
    let git_local_branch = (^git branch --show-current | str trim)
    let git_remote_branches = (^git branch -r | lines | each { |it| $it | str trim } | where ($it != $git_local_branch) and not ($it | str contains $GIT_DEFAULT_BRANCH) and not ($it | str contains $GIT_OLD_DEFAULT_BRANCH))
    mut comments = ""

    # Add specific comment for merge request
    if $mr {
        $comments += $"# Git Analysis\n"
    }

    for $remote_branch in $git_remote_branches {
        let conflicts = (^git branch-conflict $remote_branch | lines)
        if ($conflicts | length) > 0 {
            # Add specific formatting for merge request
            if $mr {
                $comments += $"## "
            }

            let remote_format_branch = ($remote_branch | str replace "origin/" "")
            $comments += $"Conflict with ($remote_format_branch)"
            if ($git_remote | str starts-with "git@gitlab.com") {
                let gitlab_mr_url = (gitlab-get-pr $remote_format_branch) | get web_url?
                if ($gitlab_mr_url | is-not-empty) {
                    $comments += $" \(see ($gitlab_mr_url)\)"
                }
            }

            if not $mr {
                $comments += $":"
            }

            $comments += $"\n"

            for $conflict in $conflicts {
                $comments += $"  - ($conflict)\n"
            }
        }
    }

    $comments = ($comments | str trim)
    if ($git_remote | str starts-with "git@gitlab.com") and $mr {
        ^glab mr note $git_local_branch --unique -m $"($comments)"
    } else {
        print $"($comments)"
    }

    if ($comments | is-not-empty) {
        exit 1
    } else {
        exit 0
    }
}

# Check for uncommitted changes and stashes in git repositories
def "main repositories check" [
    --uncommit(-u) # Check for uncommitted changes
    --stash(-s) # Check for stashes
    --branch(-b) # Check for the correct branch
    --dry-run # Dry run
]: nothing -> nothing {
    # Find all git repositories
    let git_dirs = (^git-wrapper repositories ls) | from nuon

    for repo in $git_dirs {
        if $uncommit {
            check-uncommit $repo false $dry_run
        }

        if $stash {
            check-stash $repo false $dry_run
        }

        if $branch {
            check-branch $repo $GIT_DEFAULT_BRANCH true false $dry_run
        }
    }
}

# Find all git repositories of the given path excluding submodules
def "main repositories ls" [
    --path: string = $GIT_FOLDER # Path to the git repositories
    --exclude: list<string> = ["build", ".terraform"] # Directories to exclude
]: nothing -> string {
    mut git_dirs = glob $"($path)/**/{.git}"
        | path dirname

    for filter in $exclude {
        $git_dirs = $git_dirs
            | where (not ($it | str contains $filter))
    }

    $git_dirs
        | where (^git -C $it rev-parse --show-superproject-working-tree | is-empty)
        | to nuon
}

# Sync all the git repositories
def "main repositories sync" [
    --all(-a) # Sync all the repositories
    --work # Sync only the work repositories
    --personal # Sync only the personal repositories
    --dry-run # Dry run
]: nothing -> nothing {
    mut projects = []

    if ($work or $all) {
        $projects = $projects
            | append (git-work-wrapper repositories ls | from nuon)
    }
    if ($personal or $all) {
        $projects = $projects
            | append $PERSONAL_REPOSITORIES
    }

    for project in $projects {
        if not ($"($GIT_FOLDER)/($project.path)" | path exists) {
            git-clone $project.host $project.path $"($GIT_FOLDER)/($project.path)" false $dry_run
        } else if not ($"($GIT_FOLDER)/($project.path)/.git" | path exists) {
            git-clone-non-empty-folder $project.host $project.path $"($GIT_FOLDER)/($project.path)" false $dry_run
        } else {
            git-sync $"($GIT_FOLDER)/($project.path)" true true true false $dry_run
        }
    }
}

# Cleanup all the git repositories
def "main repositories cleanup" [
    --dry-run # Dry run
    --quiet # Do not print the build directories cleaned
]: nothing -> nothing {
    # Find all git repositories
    let git_dirs = (^git-wrapper repositories ls) | from nuon

    for repo in $git_dirs {
        git-cleanup $repo $quiet $dry_run
    }
}

# Backup git repositories that have local-only data
def "main repositories backup" [
    backup_dest: path              # Destination folder for the backup archive
    ...repo_paths: path            # Paths to git repositories (if empty, uses git-wrapper repositories ls)
    --dry-run (-n)                 # Only report what would be backed up
    --quiet (-q)                   # Suppress output
    --force (-f)                   # Overwrite existing backup archive
]: nothing -> nothing {
    let backup_dest = $backup_dest | path expand
    let timestamp = (date now | format date "%Y-%m-%d")
    let archive_path = $backup_dest | path join $"git_backup_($timestamp).tar.gz"

    # Check if archive already exists
    if ($archive_path | path exists) and not $force and not $dry_run {
        print $"Backup archive ($archive_path) already exists. Use --force to overwrite."
        return
    }

    # Ensure backup destination exists
    if not $dry_run {
        mkdir $backup_dest
    }

    mut repos_to_check = []

    # If no paths provided, use git-wrapper repositories ls
    if ($repo_paths | is-empty) {
        $repos_to_check = (^git-wrapper repositories ls) | from nuon
    } else {
        for path in $repo_paths {
            let expanded_path = $path | path expand

            if ($expanded_path | path join ".git" | path exists) {
                $repos_to_check = $repos_to_check | append $expanded_path
            } else {
                if not $quiet {
                    print $"Warning: ($expanded_path) is not a git repository"
                }
            }
        }
    }

    if ($repos_to_check | is-empty) {
        if not $quiet {
            print "No git repositories found to backup."
        }
        return
    }

    # Create temp directory
    let temp_dir = if $dry_run { "" } else { mktemp -d }

    mut backed_up = 0
    mut skipped = 0

    for repo in $repos_to_check {
        let analysis = analyze-repo-backup $repo

        if $analysis.needs_backup {
            if not $quiet or $dry_run {
                print $"\nRepository: ($repo)"
                if $analysis.no_remotes { print "  - No remotes configured" }
                if $analysis.dirty { print $"  - Dirty: ($analysis.dirty_files | length) files" }
                if $analysis.stashes { print $"  - Stashes: ($analysis.stash_list | length)" }
                if ($analysis.local_only_branches | is-not-empty) {
                    print $"  - Local-only branches: ($analysis.local_only_branches | str join ', ')"
                }
                if ($analysis.ahead_branches | is-not-empty) {
                    print $"  - Ahead branches: ($analysis.ahead_branches | get branch | str join ', ')"
                }
            }

            backup-repo $repo $temp_dir $analysis $quiet $dry_run
            $backed_up += 1
        } else {
            $skipped += 1
        }
    }

    if $backed_up > 0 and not $dry_run {
        # Remove existing archive if force mode
        if ($archive_path | path exists) and $force {
            rm $archive_path
        }

        # Create tar.gz archive from temp directory
        ^tar -czf $archive_path -C $temp_dir .

        # Clean up temp directory
        rm -rf $temp_dir

        if not $quiet {
            print $"\nBackup archive created: ($archive_path)"
        }
    }

    if not $quiet {
        print $"Backup complete: ($backed_up) backed up, ($skipped) skipped"
    }
}

# Check the uncommited changes of a git repository
def "main repository check uncommit" [
    --quiet # Do not print the result
]: nothing -> bool {
    check-uncommit (pwd) $quiet true
}

# Check the stashes of a git repository
def "main repository check stash" [
    --quiet # Do not print the result
]: nothing -> bool {
    check-stash (pwd) $quiet true
}

# Check if the branch is the correct one, and up to date
def "main repository check branch" [
    --branch: string # Branch to check
    --up-to-date # Check if the branch is up to date
    --quiet # Do not print the result
]: nothing -> bool {
    check-branch (pwd) $branch $up_to_date $quiet true
}

# Sync the git repository branches
def "main repository sync branches" [
    --quiet # Do not print the result
]: nothing -> nothing {
    git-sync (pwd) true false false $quiet false
}

# Sync the git repository tags
def "main repository sync tags" [
    --quiet # Do not print the result
]: nothing -> nothing {
    git-sync (pwd) false true false $quiet false
}

# Sync the git repository submodules
def "main repository sync submodules" [
    --quiet # Do not print the result
]: nothing -> nothing {
    git-sync (pwd) false false true $quiet false
}

# Commit the changes of a git repository using conventional commit
def "main repository commit" [
    --message(-m): string # Message of the commit
    --commit-type(-t): string # Commit type
    --commit-scope(-s): string # Commit scope
    --commit-breaking(-b) # Mark commit as breaking
    --emoji # Use emoji in the commit message
    --all(-a) # Automatically stage all modified, newly and deleted files
    --quiet # Do not print the result
] {
    const commit_type_emoticons = {
        "build": "ðŸ› "
        "chore": "â™»ï¸"
        "ci": "âš™ï¸"
        "docs": "ðŸ“š"
        "feat": "âœ¨"
        "fix": "ðŸ›"
        "perf": "ðŸš€"
        "refactor": "ðŸ“¦"
        "revert": "ðŸ—‘"
        "style": "ðŸ’Ž"
        "test": "ðŸš¨"
        "release": "ðŸ”–"
        "sec": "ðŸ”’"
        "wip": "ðŸš§"
    }

    # Ensure we have the mandatory information, ask if not
    mut msg_commit_type = $commit_type
    while ($msg_commit_type == null or $msg_commit_type == "" or (not ($msg_commit_type in $commit_type_emoticons))) {
        $msg_commit_type = (input $"Enter the commit type: ")
    }

    mut msg_commit_scope = $commit_scope
    while ($msg_commit_scope == null) {
        $msg_commit_scope = (input "Enter the commit scope: ")
    }

    mut msg_message = $message
    while ($msg_message == null or $msg_message == "") {
        $msg_message = (input "Enter commit message: ")
    }

    # Generate full commit message
    let $msg_commit_scope = if ($msg_commit_scope != null and $msg_commit_scope != "") {
        $"\(($msg_commit_scope)\)"
    } else {
        ""
    }
    let $msg_commit_breaking = if ($commit_breaking) {
        "!"
    } else {
        ""
    }
    let $msg_emoji = if ($emoji and $msg_commit_type in $commit_type_emoticons) {
        $"($commit_type_emoticons | get $msg_commit_type) "
    } else {
        ""
    }

    let $msg_full = ({
        type: $msg_commit_type
        scope: $msg_commit_scope
        breaking: $msg_commit_breaking
        emoji: $msg_emoji
        msg: $msg_message
    } | format pattern "{type}{scope}{breaking}: {emoji}{msg}")

    if not $quiet {
        print $"\nCommitting '($msg_full)' to the repository"
    }

    # Commit the changes
    if $all {
        ^git add .
    }

    ^git commit --message $msg_full
}

def main []: nothing -> nothing {}
