#!/usr/bin/env bash
#
# Copyright (c) Jérémy Audiger.
# All rights reserved.
#

print_usage_and_exit() {
    echo "Usage: $0 [OPTIONS] FOLDER"
    echo "  OPTIONS:"
    echo "    -b, --backup: Backup important files"
    echo "    -r, --restore: Restore the files"
    echo "    -f, --force: Force mode"
    echo "    --help: Display this help and exit"
    echo "  FOLDER: Folder where to save or load the archive"

    exit 1
}

do_backup() {
    echo "Backup important files..."

    local -r FOLDER=${1}

    # Check if the folder exist
    if [[ ! -d "${FOLDER}" ]]; then
        echo "Folder '${FOLDER}' does not exist to backup the archive"
        return
    fi

    local -r TIMESTAMP="$(date +%Y-%m-%d || true)"
    local -r ARCHIVE_OUTPUT="${FOLDER}/backup_${TIMESTAMP}.tar"
    local -r COMPRESSED_ARCHIVE_OUTPUT="${ARCHIVE_OUTPUT}.gz"

    # Check if the file already exist
    if [[ -f "${COMPRESSED_ARCHIVE_OUTPUT}" ]]; then
        if [[ "${FORCE}" = 0 ]]; then
            echo "Backup file ${COMPRESSED_ARCHIVE_OUTPUT} already exist"
            return
        fi

        rm "${COMPRESSED_ARCHIVE_OUTPUT}"
    fi

    # Backup folders
    BACKUP_FOLDERS=(
        Development/vscode
        Development/work-scripts
    )

    # First, archive raw folders
    tar -czf "${ARCHIVE_OUTPUT}" "${BACKUP_FOLDERS[@]}"
    # Then, archive files from find commands (to better handle folders with spaces)
    find Development/git-repositories -type d \( -name '.claude' -o -name '.devcontainer' -o -name '.idea' -o -name '.vscode' -o -name '.zed' \) -exec tar -rf "${ARCHIVE_OUTPUT}" {} +
    find Development/git-repositories -type f \( -name 'CLAUDE.md' \) -exec tar -rf "${ARCHIVE_OUTPUT}" {} +
    find .config/JetBrains/**/codestyles -type f \( -iname '*.xml' -and ! -iname 'Default.xml' \) -exec tar -rf "${ARCHIVE_OUTPUT}" {} +

    # Backup SSH keys (public/private pairs only)
    find .ssh -maxdepth 1 -type f -name 'id_*' -exec tar -rf "${ARCHIVE_OUTPUT}" {} +

    # Backup GPG keys using proper export commands
    GPG_BACKUP_DIR=$(mktemp -d)
    gpg --export --armor > "${GPG_BACKUP_DIR}/gpg-public-keys.asc"
    gpg --export-secret-keys --armor > "${GPG_BACKUP_DIR}/gpg-secret-keys.asc"
    gpg --export-ownertrust > "${GPG_BACKUP_DIR}/gpg-ownertrust.txt"
    tar -rf "${ARCHIVE_OUTPUT}" -C "${GPG_BACKUP_DIR}" .
    rm -rf "${GPG_BACKUP_DIR}"

    # Compress the archive
    gzip "${ARCHIVE_OUTPUT}"

    echo "Files backup into ${COMPRESSED_ARCHIVE_OUTPUT}"
}

do_restore() {
    echo "Restore files..."

    BACKUP_FILE=${1}

    # Check file
    if [[ ! -f "${BACKUP_FILE}" ]]; then
        echo "Backup file ${BACKUP_FILE} does not exist"
        return
    fi

    # Extract the files
    tar -xf "${BACKUP_FILE}"

    # Fix SSH key permissions after restore
    if [[ -d "${HOME}/.ssh" ]]; then
        chmod 700 "${HOME}/.ssh"
        find "${HOME}/.ssh" -type f -name 'id_*' ! -name '*.pub' -exec chmod 600 {} +
        find "${HOME}/.ssh" -type f -name '*.pub' -exec chmod 644 {} +
    fi

    # Restore GPG keys
    if [[ -f "gpg-public-keys.asc" ]]; then
        gpg --import gpg-public-keys.asc
        rm gpg-public-keys.asc
    fi
    if [[ -f "gpg-secret-keys.asc" ]]; then
        gpg --import gpg-secret-keys.asc
        rm gpg-secret-keys.asc
    fi
    if [[ -f "gpg-ownertrust.txt" ]]; then
        gpg --import-ownertrust gpg-ownertrust.txt
        rm gpg-ownertrust.txt
    fi

    echo "Files has been restored"
}

# Default constants
BACKUP=0
RESTORE=0
FORCE=0

# Option parsing
while [[ "$#" -gt 0 ]]; do
    case "${1}" in
    -b)
        BACKUP=1
        shift 1
        ;;

    --backup)
        BACKUP=1
        shift 1
        ;;

    -r)
        RESTORE=1
        shift 1
        ;;

    --restore)
        RESTORE=1
        shift 1
        ;;

    -f)
        FORCE=1
        shift 1
        ;;

    --force)
        FORCE=1
        shift 1
        ;;

    --help)
        print_usage_and_exit
        ;;

    -*)
        echo "Invalid option ${1}."
        print_usage_and_exit
        ;;

    *)
        ARGUMENT=${1}
        break
        ;;
    esac
done

if [[ -z "${ARGUMENT}" ]] || { [[ "${BACKUP}" = 0 ]] && [[ "${RESTORE}" = 0 ]]; }; then
    print_usage_and_exit
fi

# Check if the path is relative
if [[ ! "${ARGUMENT}" = /* ]]; then
    CURRENT_DIR="$(pwd)"

    ARGUMENT="${CURRENT_DIR}/${ARGUMENT}"
fi

cd "${HOME}" || exit # Go to user folder

if [[ "${BACKUP}" = 1 ]]; then
    do_backup "${ARGUMENT}"
else
    do_restore "${ARGUMENT}"
fi
